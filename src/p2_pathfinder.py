#Alon Pekurovsky#Dean Rabinowitzfrom heapq import heappop, heappushimport sysdef find_path (source_point, destination_point, mesh):    print(source_point)    print(destination_point)    #print(mesh['boxes'], '\n')    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {} #like prev    found = False    #step 1 identify which boxes contain source and destination    for box in mesh['boxes']:        if box[3] >= source_point[1] >= box[2]:            if box[1] >= source_point[0] >= box[0]:                boxes[box] = 0                start_box = box                print ('start:', start_box)        elif box[3] >= destination_point[1] >= box[2]:            if box[1] >= destination_point[0] >= box[0]:                #boxes[box] = 0                dest_box = box                print('dest:', dest_box)    #step 2 implement BFS    dist = {}    queue = []    queue.append(start_box)    boxes[start_box] = 0    while len(queue) != 0:        current_box = queue.pop(0)        if current_box == dest_box:            print('matched')            # construct the path            path = []            while current_box in boxes:                path.insert(0, current_box)                current_box = boxes[current_box]            path.insert(0, start_box)            found = True            break        #print(mesh['adj'][current_box])        for neighbor_box in mesh['adj'][current_box]:            # if neighbor_box == dest_box:            #     print('matched')            #     # construct the path            #     path = []            #     while current_box in boxes:            #         path.insert(0, current_box)            #         current_box = boxes[current_box]            #     path.insert(0, start_box)            #     found = True            #     break            if neighbor_box not in boxes:                boxes[neighbor_box] = current_box                queue.append(neighbor_box)                print(queue)            #new_dist = neighbor_cost + dist[current_cell]            # if (neighbor_cell not in dist) or (new_dist < dist[neighbor_cell]):            #     dist[neighbor_cell] = new_dist            #     prev[neighbor_cell] = current_cell            #     heappush(queue, (new_dist, neighbor_cell))    if not found:        print('No path found!')    print(boxes.keys())    return path, boxes.keys()